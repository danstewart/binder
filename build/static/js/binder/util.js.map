{"version":3,"sources":["../../../../src/static/js/binder/util.js"],"sourcesContent":["const pascalToKebab = str => str[0].toLowerCase() + str.slice(1, str.length).replace(/[A-Z0-9]/g, letter => `-${letter.toLowerCase()}`);\n\nconst kebabToCamel = str => str[0].toLowerCase() + str.slice(1, str.length).replace(/-([a-z0-9])/g, letter => `${letter[1].toUpperCase()}`);\n\n/**\n * Returns the permutations of an array for all combinations and lengths\n * @param {*} arr\n */\nconst permutations = (arr, toString = false) => {\n    // Group each chunk of permutations of each length\n    // ie. group all the length-1 permutations, and the length-2 permutations, etc...\n    let chunks = {};\n\n    // Add the initial array (length-1 permutations)\n    chunks[1] = arr.map(item => [item]);\n\n    // Add the permutations from length-2 to the full length of the initial array\n    for (let targetLen = 2; targetLen <= arr.length; targetLen++) {\n        let newChunk = [];\n\n        // Go through each permutation of the previous length\n        // and each value in the initial array\n        // If the permutation does not contain the current loop value then make a new permutation\n        // with the old permutation and the current loop value\n        for (let permutation of chunks[targetLen - 1]) {\n            for (let item of arr) {\n                if (permutation.includes(item)) continue;\n                newChunk.push([item, ...permutation]);\n            }\n        }\n\n        chunks[targetLen] = newChunk;\n    }\n\n    let results = Object.values(chunks);\n\n    // If we want the results as a flat list of strings (which we probably do)\n    // Then do it...\n    if (toString) {\n        let formattedResults = [];\n        for (let group of results) {\n            for (let permutation of group) {\n                formattedResults.push(permutation.join(\"\"));\n            }\n        }\n\n        return formattedResults;\n    }\n\n    return results;\n};\n\n/**\n * Parses a duration string and returns the time in milliseconds\n * Durations are in the form: ${duration: number}${unit: string}\n * EG.\n * 5ms => 5 milliseconds\n * 30s => 30 seconds\n * 5m => 5 minutes\n * 2h => 2 hours\n * @param {string} duration A string duration\n */\nconst parseDuration = duration => {\n    const [_, interval, unit] = /(\\d+)(\\w+)/.exec(duration);\n\n    // Calculate the duration in milliseconds\n    // Supported units are:\n    // ms: milliseconds\n    // s: seconds\n    // m: minutes\n    // h: hours\n    let timeout = 0;\n    switch (unit) {\n        case \"ms\":\n            timeout = interval;\n            break;\n        case \"s\":\n            timeout = interval * 1000;\n            break;\n        case \"m\":\n            timeout = interval * 1000 * 60;\n            break;\n        case \"h\":\n            timeout = interval * 1000 * 60 * 60;\n            break;\n    }\n\n    return timeout;\n};\n\n// Allows defining template literals with syntax highlighting\nconst template = (strings, ...values) => {\n    return strings.reduce((acc, str, i) => {\n        return acc + str + (values[i] || \"\");\n    }, \"\");\n};\n\n/**\n * Parse a string as a boolean\n * Falsey values are\n * - 0 or \"0\"\n * - false or \"false\" (case insensitive)\n * - null or undefined\n * NOTE: An empty string is **true**, this is so an empty HTML attribute is true, like normal HTML boolean attributes (eg. disabled and hidden)\n * @param {*} value\n * @returns {boolean}\n */\nconst parseBoolean = value => {\n    if (value === null || value === undefined) {\n        return false;\n    }\n\n    if (value === false) {\n        return false;\n    }\n\n    if (value === 0 || value === \"0\") {\n        return false;\n    }\n\n    if (value && value.toLowerCase && value.toLowerCase() === \"false\") {\n        return false;\n    }\n\n    return true;\n};\n\nexport { pascalToKebab, kebabToCamel, permutations, parseDuration, template as html, template as css, parseBoolean };\n"],"names":["pascalToKebab","str","toLowerCase","slice","length","replace","letter","kebabToCamel","toUpperCase","permutations","arr","toString","chunks","map","item","targetLen","newChunk","permutation","includes","push","results","Object","values","formattedResults","group","join","parseDuration","duration","_","interval","unit","exec","timeout","template","strings","reduce","acc","i","parseBoolean","value","undefined","html","css"],"mappings":"AAAA,MAAMA,cAAgBC,KAAOA,GAAG,CAAC,EAAE,CAACC,WAAW,GAAKD,IAAIE,KAAK,CAAC,EAAGF,IAAIG,MAAM,EAAEC,OAAO,CAAC,YAAaC,QAAU,CAAC,CAAC,EAAEA,OAAOJ,WAAW,GAAG,CAAC,EAEtI,MAAMK,aAAeN,KAAOA,GAAG,CAAC,EAAE,CAACC,WAAW,GAAKD,IAAIE,KAAK,CAAC,EAAGF,IAAIG,MAAM,EAAEC,OAAO,CAAC,eAAgBC,QAAU,CAAC,EAAEA,MAAM,CAAC,EAAE,CAACE,WAAW,GAAG,CAAC,EAM1I,MAAMC,aAAe,CAACC,IAAKC,SAAW,KAAK,IAGvC,IAAIC,OAAS,CAAC,CAGdA,CAAAA,MAAM,CAAC,EAAE,CAAGF,IAAIG,GAAG,CAACC,MAAQ,CAACA,KAAK,EAGlC,IAAK,IAAIC,UAAY,EAAGA,WAAaL,IAAIN,MAAM,CAAEW,YAAa,CAC1D,IAAIC,SAAW,EAAE,CAMjB,IAAK,IAAIC,eAAeL,MAAM,CAACG,UAAY,EAAE,CAAE,CAC3C,IAAK,IAAID,QAAQJ,IAAK,CAClB,GAAIO,YAAYC,QAAQ,CAACJ,MAAO,SAChCE,SAASG,IAAI,CAAC,CAACL,QAASG,YAAY,CACxC,CACJ,CAEAL,MAAM,CAACG,UAAU,CAAGC,QACxB,CAEA,IAAII,QAAUC,OAAOC,MAAM,CAACV,QAI5B,GAAID,SAAU,CACV,IAAIY,iBAAmB,EAAE,CACzB,IAAK,IAAIC,SAASJ,QAAS,CACvB,IAAK,IAAIH,eAAeO,MAAO,CAC3BD,iBAAiBJ,IAAI,CAACF,YAAYQ,IAAI,CAAC,IAC3C,CACJ,CAEA,OAAOF,gBACX,CAEA,OAAOH,OACX,EAYA,MAAMM,cAAgBC,WAClB,KAAM,CAACC,EAAGC,SAAUC,KAAK,CAAG,aAAaC,IAAI,CAACJ,UAQ9C,IAAIK,QAAU,EACd,OAAQF,MACJ,IAAK,KACDE,QAAUH,SACV,KACJ,KAAK,IACDG,QAAUH,SAAW,IACrB,KACJ,KAAK,IACDG,QAAUH,SAAW,IAAO,GAC5B,KACJ,KAAK,IACDG,QAAUH,SAAW,IAAO,GAAK,GACjC,KACR,CAEA,OAAOG,OACX,EAGA,MAAMC,SAAW,CAACC,QAAS,GAAGZ,UAC1B,OAAOY,QAAQC,MAAM,CAAC,CAACC,IAAKnC,IAAKoC,KAC7B,OAAOD,IAAMnC,IAAOqB,CAAAA,MAAM,CAACe,EAAE,EAAI,EAAC,CACtC,EAAG,GACP,EAYA,MAAMC,aAAeC,QACjB,GAAIA,QAAU,MAAQA,QAAUC,UAAW,CACvC,OAAO,KACX,CAEA,GAAID,QAAU,MAAO,CACjB,OAAO,KACX,CAEA,GAAIA,QAAU,GAAKA,QAAU,IAAK,CAC9B,OAAO,KACX,CAEA,GAAIA,OAASA,MAAMrC,WAAW,EAAIqC,MAAMrC,WAAW,KAAO,QAAS,CAC/D,OAAO,KACX,CAEA,OAAO,IACX,CAEA,QAASF,aAAa,CAAEO,YAAY,CAAEE,YAAY,CAAEiB,aAAa,CAAEO,YAAYQ,IAAI,CAAER,YAAYS,GAAG,CAAEJ,YAAY,CAAG"}